var wordMap = {
  "one": "一",
  "two": "二",
  "three": "三",
  "four": "四",
  "five": "五",
  "six": "六",
  "seven": "七",
  "eight": "八",
  "nine": "九",
  "ten": "十",
  "mouth": "口",
  "day": "日",
  "month": "月",
  "rice field": "田",
  "eye": "目",
  "old": "古",
  "bright": "明",
  "goods": "品",
  "early": "早",
  "generation": "世",
  "oneself": "自",
  "white": "白",
  "hundred": "百",
  "in/center": "中",
  "thousand": "千",
  "above": "上",
  "below": "下",
  "morning": "朝",
  "employee": "員",
  "see": "見",
  "beginning": "元",
  "defeat": "負",
  "ten thousand": "万",
  "neck": "首",
  "straightaway": "直",
  "tool": "具",
  "true": "真",
  "craft": "工",
  "left": "左",
  "right": "右",
  "possess": "有",
  "cut": "切",
  "separate": "別",
  "village": "町",
  "place on the head": "頂",
  "child": "子",
  "woman": "女",
  "fond": "好",
  "mama": "母",
  "elder brother": "兄",
  "little": "小",
  "few": "少",
  "large": "大",
  "many": "多",
  "evening": "夕",
  "outside": "外",
  "name": "名",
  "stone": "石",
  "ray": "光",
  "plump": "太",
  "stream": "川",
  "water": "水",
  "meadow": "原",
  "petition": "願",
  "swim": "泳",
  "lively": "活",
  "extinguish": "消",
  "soil": "土",
  "time": "時",
  "fire": "火",
  "spot": "点",
  "fish": "魚",
  "black": "黒",
  "same": "同",
  "yonder": "向",
  "character": "字",
  "guard": "守",
  "perfect": "完",
  "relax": "安",
  "draw near": "寄",
  "wealth": "富",
  "tree": "木",
  "inter-": "相",
  "book": "本",
  "not yet": "未",
  "extremity": "末",
  "flavor": "味",
  "younger sister": "妹",
  "young": "若",
  "grass": "草",
  "suffering": "苦",
  "leaf": "葉",
  "livelihood": "暮",
  "dog": "犬",
  "status quo": "状",
  "sort of thing": "然",
  "cat": "猫",
  "cow": "牛",
  "special": "特",
  "revelation": "告",
  "before": "先",
  "wash": "洗",
  "world": "界",
  "tea": "茶",
  "fit": "合",
  "king": "王",
  "present": "現",
  "whole": "全",
  "logic": "理",
  "lord": "主",
  "pour": "注",
  "gold": "金",
  "road-way": "道",
  "escape": "逃",
  "car": "車",
  "take along": "連",
  "in front": "前",
  "status": "格",
  "guest": "客",
  "summer": "夏",
  "dispose": "処",
  "fall": "落",
  "carry": "運",
  "dream": "夢",
  "tall": "高",
  "capital": "京",
  "scenery": "景",
  "week": "週",
  "sell": "売",
  "study": "学",
  "memorize": "覚",
  "write": "書",
  "failure": "敗",
  "say": "言",
  "admonish": "警",
  "plot": "計",
  "tale": "話",
  "word": "語",
  "read": "読",
  "tune": "調",
  "discuss": "談",
  "style": "式",
  "test": "試",
  "turn into": "成",
  "stop": "止",
  "walk": "歩",
  "correct": "正",
  "politics": "政",
  "determine": "定",
  "run": "走",
  "surpass": "越",
  "topic": "題",
  "build": "建",
  "distant": "遠",
  "first time": "初",
  "market": "市",
  "elder sister": "姉",
  "system": "制",
  "revolve": "転",
  "rain": "雨",
  "winter": "冬",
  "heavens": "天",
  "stand up": "立",
  "make a deal": "商",
  "suitable": "適",
  "north": "北",
  "stature": "背",
  "all": "皆",
  "every": "毎",
  "sea": "海",
  "abdomen": "腹",
  "lack": "欠",
  "blow": "吹",
  "song": "歌",
  "next": "次",
  "assets": "資",
  "sound": "音",
  "darkness": "暗",
  "discriminating": "識",
  "deceased": "亡",
  "ambition": "望",
  "direction": "方",
  "call on": "訪",
  "set free": "放",
  "explanation": "説",
  "increase": "増",
  "east": "東",
  "year-end": "歳",
  "ground": "地",
  "wind": "風",
  "rouse": "起",
  "scribe": "記",
  "electricity": "電",
  "house": "家",
  "location": "場",
  "beauty": "美",
  "ocean": "洋",
  "accomplished": "達",
  "distinction": "差",
  "don": "着",
  "gather": "集",
  "advance": "進",
  "miscellaneous": "雑",
  "assurance": "確",
  "noon": "午",
  "permit": "許",
  "authority": "権",
  "outlook": "観",
  "learn": "習",
  "weekday": "曜",
  "quandary": "困",
  "country": "国",
  "cause": "因",
  "park": "園",
  "-times": "回",
  "store": "店",
  "courtyard": "庭",
  "heart": "心",
  "forget": "忘",
  "acknowledge": "認",
  "think": "思",
  "idea": "意",
  "concept": "想",
  "breath": "息",
  "fear": "恐",
  "emotion": "感",
  "busy": "忙",
  "dreadful": "怖",
  "accustomed": "慣",
  "invariably": "必",
  "hand": "手",
  "deliberation": "議",
  "embrace": "抱",
  "beckon": "招",
  "strike": "打",
  "finger": "指",
  "hold": "持",
  "hang": "掛",
  "polish": "研",
  "genius": "才",
  "property": "財",
  "suppose": "存",
  "exist": "在",
  "suck": "吸",
  "grow late": "更",
  "angry": "怒",
  "friend": "友",
  "slip out": "抜",
  "throw": "投",
  "branch": "支",
  "anti-": "反",
  "return": "返",
  "floating": "浮",
  "accept": "受",
  "love": "愛",
  "pay": "払",
  "wide": "広",
  "pedestal": "台",
  "reign / cure": "治",
  "commence": "始",
  "window": "窓",
  "gone": "去",
  "method": "法",
  "meeting": "会",
  "room": "室",
  "arrival": "到",
  "mutually": "互",
  "bring up": "育",
  "current": "流",
  "exit": "出",
  "mountain": "山",
  "enter": "入",
  "crowded": "込",
  "poverty": "貧",
  "public": "公",
  "contain": "容",
  "longing": "欲",
  "hall": "堂",
  "usual": "常",
  "rend": "破",
  "remainder": "残",
  "file": "列",
  "death": "死",
  "ear": "耳",
  "take": "取",
  "utmost": "最",
  "shame": "恥",
  "post": "職",
  "buy": "買",
  "placement": "置",
  "husband": "夫",
  "standard": "規",
  "approve": "賛",
  "lose": "失",
  "power": "力",
  "man": "男",
  "labor": "労",
  "toil": "努",
  "add": "加",
  "going": "行",
  "gain": "得",
  "junior": "徒",
  "wait": "待",
  "he": "彼",
  "duty": "役",
  "extent": "程",
  "harmony": "和",
  "autumn": "秋",
  "private": "私",
  "profit": "利",
  "rice": "米",
  "astray": "迷",
  "number": "数",
  "sort": "類",
  "Esq.": "様",
  "request": "求",
  "ball": "球",
  "laugh": "笑",
  "box": "箱",
  "etc.": "等",
  "solution": "答",
  "person": "人",
  "dwell": "住",
  "rank": "位",
  "body": "体",
  "affair": "件",
  "attend": "仕",
  "other": "他",
  "transmit": "伝",
  "rest": "休",
  "faith": "信",
  "example": "例",
  "side": "側",
  "price": "値",
  "overthrow": "倒",
  "use": "使",
  "convenience": "便",
  "tenderness": "優",
  "inn": "宿",
  "adhere": "付",
  "responsibility": "任",
  "substitute": "代",
  "lend": "貸",
  "change": "化",
  "flower": "花",
  "what": "何",
  "inside": "内",
  "meat": "肉",
  "sit": "座",
  "by means of": "以",
  "similar": "似",
  "year": "年",
  "night": "夜",
  "play": "遊",
  "trip": "旅",
  "thing": "物",
  "easy": "易",
  "roof": "屋",
  "reside": "居",
  "bureau": "局",
  "slow": "遅",
  "daytime": "昼",
  "re-": "戻",
  "show": "示",
  "salutation": "礼",
  "blessing": "福",
  "company": "社",
  "guess": "察",
  "wherefore": "由",
  "push": "押",
  "speaketh": "申",
  "gods": "神",
  "fruit": "果",
  "place": "所",
  "near": "近",
  "fold": "折",
  "severance": "断",
  "substance": "質",
  "yesterday": "昨",
  "make": "作",
  "snow": "雪",
  "hurry": "急",
  "lie down": "寝",
  "lady": "婦",
  "hit": "当",
  "contend": "争",
  "matter": "事",
  "old boy": "君",
  "both": "両",
  "full": "満",
  "brush-stroke": "画",
  "tooth": "歯",
  "bend": "曲",
  "fee": "料",
  "department": "科",
  "map": "図",
  "utilize": "用",
  "equip": "備",
  "once upon a time": "昔",
  "borrow": "借",
  "scatter": "散",
  "seat": "席",
  "degrees": "度",
  "transit": "渡",
  "half": "半",
  "judgment": "判",
  "victory": "勝",
  "negative": "不",
  "negate": "否",
  "cupfuls": "杯",
  "tribe": "族",
  "know": "知",
  "task": "務",
  "homecoming": "帰",
  "pull": "引",
  "strong": "強",
  "expense": "費",
  "younger brother": "弟",
  "nickname": "号",
  "bestow": "与",
  "copy": "写",
  "old man": "老",
  "consider": "考",
  "teach": "教",
  "someone": "者",
  "chase": "追",
  "expert": "師",
  "bureaucrat": "官",
  "father": "父",
  "mingle": "交",
  "exam": "校",
  "leg": "足",
  "path": "路",
  "overdo": "過",
  "occasion": "際",
  "sunshine": "陽",
  "Inst.": "院",
  "descend": "降",
  "empty": "空",
  "stab": "突",
  "research": "究",
  "grope": "探",
  "deep": "深",
  "thong": "緒",
  "continue": "続",
  "picture": "絵",
  "salary": "給",
  "end": "終",
  "sūtra": "経",
  "promise": "約",
  "behind": "後",
  "how many": "幾",
  "mechanism": "機",
  "person in charge": "係",
  "honorable": "御",
  "clothing": "服",
  "fate": "命",
  "cool": "冷",
  "traffic": "通",
  "doubt": "疑",
  "crime": "犯",
  "dangerous": "危",
  "detain": "留",
  "saké": "酒",
  "distribute": "配",
  "head": "頭",
  "rejoice": "喜",
  "steal": "盗",
  "silver": "銀",
  "retreat": "退",
  "limit": "限",
  "good": "良",
  "daughter": "娘",
  "eat": "食",
  "meal": "飯",
  "drink": "飲",
  "Bldg.": "館",
  "even": "平",
  "call": "呼",
  "kill": "殺",
  "resign": "辞",
  "new": "新",
  "parent": "親",
  "happiness": "幸",
  "report": "報",
  "income": "収",
  "heat": "熱",
  "engrave": "刻",
  "art": "術",
  "cold": "寒",
  "blue": "青",
  "refined": "精",
  "feelings": "情",
  "clear up": "晴",
  "quiet": "静",
  "blame": "責",
  "volume": "積",
  "surface": "表",
  "harm": "害",
  "proportion": "割",
  "life": "生",
  "sex": "性",
  "products": "産",
  "springtime": "春",
  "reality": "実",
  "diligence": "勤",
  "Sino-": "漢",
  "difficult": "難",
  "ride": "乗",
  "now": "今",
  "wish": "念",
  "beforehand": "予",
  "plains": "野",
  "west": "西",
  "need": "要",
  "smoke": "煙",
  "south": "南",
  "question": "問",
  "interval": "間",
  "open": "開",
  "closed": "閉",
  "hear": "聞",
  "un-": "非",
  "sad": "悲",
  "guilt": "罪",
  "climate": "候",
  "decide": "決",
  "admirable": "偉",
  "difference": "違",
  "too much": "余",
  "exclude": "除",
  "route": "途",
  "bundle": "束",
  "trust": "頼",
  "quick": "速",
  "precipitous": "険",
  "heavy": "重",
  "move": "動",
  "work": "働",
  "species": "種",
  "ill": "病",
  "tired": "疲",
  "pain": "痛",
  "doctor": "医",
  "welcome": "迎",
  "ascend": "登",
  "discharge": "発",
  "shape": "形",
  "face": "顔",
  "visit": "参",
  "sentence": "文",
  "vis-à-vis": "対",
  "finish": "済",
  "music": "楽",
  "medicine": "薬",
  "England": "英",
  "reflect": "映",
  "red": "赤",
  "unusual": "変",
  "sideways": "横",
  "color": "色",
  "discontinue": "絶",
  "period": "期",
  "dance": "舞",
  "association": "組",
  "ancestor": "祖",
  "help": "助",
  "profession": "業",
  "together": "共",
  "submit": "供",
  "harbor": "港",
  "elect": "選",
  "bad": "悪",
  "circle": "円",
  "unravel": "解",
  "posture": "構",
  "argument": "論",
  "paper": "紙",
  "marriage": "婚",
  "people": "民",
  "sleepy": "眠",
  "catch": "捕",
  "section": "部",
  "metropolis": "都",
  "grade": "段",
  "ship": "船",
  "come": "来",
  "spirit": "気",
  "fly": "飛",
  "wife": "妻",
  "mask": "面",
  "shoes": "靴",
  "voice": "声",
  "mistake": "誤",
  "turn": "番",
  "home": "宅",
  "long": "長",
  "hair of the head": "髪",
  "simple": "単",
  "war": "戦",
  "bird": "鳥",
  "chirp": "鳴",
  "accidentally": "偶",
  "nightfall": "晩",
  "exertion": "勉",
  "horse": "馬",
  "verification": "験",
  "station": "駅",
  "ability": "能",
  "performance": "演",
  "send off": "送",
  "connection": "関"
};

/**
 * findAndReplaceDOMText v 0.4.6
 * @author James Padolsey http://james.padolsey.com
 * @license http://unlicense.org/UNLICENSE
 *
 * https://github.com/padolsey/findAndReplaceDOMText
 *
 * Matches the text of a DOM node against a regular expression
 * and replaces each match (or node-separated portions of the match)
 * in the specified element.
 */
(function (root, factory) {
  if (typeof module === 'object' && module.exports) {
    // Node/CommonJS
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(factory);
  } else {
    // Browser globals
    root.findAndReplaceDOMText = factory();
  }
}(this, function factory() {

  var PORTION_MODE_RETAIN = 'retain';
  var PORTION_MODE_FIRST = 'first';

  var doc = document;
  var hasOwn = {}.hasOwnProperty;

  function escapeRegExp(s) {
    return String(s).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  function exposed() {
    // Try deprecated arg signature first:
    return deprecated.apply(null, arguments) || findAndReplaceDOMText.apply(null, arguments);
  }

  function deprecated(regex, node, replacement, captureGroup, elFilter) {
    if ((node && !node.nodeType) && arguments.length <= 2) {
      return false;
    }
    var isReplacementFunction = typeof replacement == 'function';

    if (isReplacementFunction) {
      replacement = (function(original) {
        return function(portion, match) {
          return original(portion.text, match.startIndex);
        };
      }(replacement));
    }

    // Awkward support for deprecated argument signature (<0.4.0)
    var instance = findAndReplaceDOMText(node, {

      find: regex,

      wrap: isReplacementFunction ? null : replacement,
      replace: isReplacementFunction ? replacement : '$' + (captureGroup || '&'),

      prepMatch: function(m, mi) {

        // Support captureGroup (a deprecated feature)

        if (!m[0]) throw 'findAndReplaceDOMText cannot handle zero-length matches';

        if (captureGroup > 0) {
          var cg = m[captureGroup];
          m.index += m[0].indexOf(cg);
          m[0] = cg;
        }

        m.endIndex = m.index + m[0].length;
        m.startIndex = m.index;
        m.index = mi;

        return m;
      },
      filterElements: elFilter
    });

    exposed.revert = function() {
      return instance.revert();
    };

    return true;
  }

  /**
   * findAndReplaceDOMText
   *
   * Locates matches and replaces with replacementNode
   *
   * @param {Node} node Element or Text node to search within
   * @param {RegExp} options.find The regular expression to match
   * @param {String|Element} [options.wrap] A NodeName, or a Node to clone
   * @param {String} [options.wrapClass] A classname to append to the wrapping element
   * @param {String|Function} [options.replace='$&'] What to replace each match with
   * @param {Function} [options.filterElements] A Function to be called to check whether to
   *	process an element. (returning true = process element,
   *	returning false = avoid element)
   */
  function findAndReplaceDOMText(node, options) {
    return new Finder(node, options);
  }

  exposed.NON_PROSE_ELEMENTS = {
    br:1, hr:1,
    // Media / Source elements:
    script:1, style:1, img:1, video:1, audio:1, canvas:1, svg:1, map:1, object:1,
    // Input elements
    input:1, textarea:1, select:1, option:1, optgroup: 1, button:1
  };

  exposed.NON_CONTIGUOUS_PROSE_ELEMENTS = {

    // Elements that will not contain prose or block elements where we don't
    // want prose to be matches across element borders:

    // Block Elements
    address:1, article:1, aside:1, blockquote:1, dd:1, div:1,
    dl:1, fieldset:1, figcaption:1, figure:1, footer:1, form:1, h1:1, h2:1, h3:1,
    h4:1, h5:1, h6:1, header:1, hgroup:1, hr:1, main:1, nav:1, noscript:1, ol:1,
    output:1, p:1, pre:1, section:1, ul:1,
    // Other misc. elements that are not part of continuous inline prose:
    br:1, li: 1, summary: 1, dt:1, details:1, rp:1, rt:1, rtc:1,
    // Media / Source elements:
    script:1, style:1, img:1, video:1, audio:1, canvas:1, svg:1, map:1, object:1,
    // Input elements
    input:1, textarea:1, select:1, option:1, optgroup:1, button:1,
    // Table related elements:
    table:1, tbody:1, thead:1, th:1, tr:1, td:1, caption:1, col:1, tfoot:1, colgroup:1

  };

  exposed.NON_INLINE_PROSE = function(el) {
    return hasOwn.call(exposed.NON_CONTIGUOUS_PROSE_ELEMENTS, el.nodeName.toLowerCase());
  };

  // Presets accessed via `options.preset` when calling findAndReplaceDOMText():
  exposed.PRESETS = {
    prose: {
      forceContext: exposed.NON_INLINE_PROSE,
      filterElements: function(el) {
        return !hasOwn.call(exposed.NON_PROSE_ELEMENTS, el.nodeName.toLowerCase());
      }
    }
  };

  exposed.Finder = Finder;

  /**
   * Finder -- encapsulates logic to find and replace.
   */
  function Finder(node, options) {

    var preset = options.preset && exposed.PRESETS[options.preset];

    options.portionMode = options.portionMode || PORTION_MODE_RETAIN;

    if (preset) {
      for (var i in preset) {
        if (hasOwn.call(preset, i) && !hasOwn.call(options, i)) {
          options[i] = preset[i];
        }
      }
    }

    this.node = node;
    this.options = options;

    // Enable match-preparation method to be passed as option:
    this.prepMatch = options.prepMatch || this.prepMatch;

    this.reverts = [];

    this.matches = this.search();

    if (this.matches.length) {
      this.processMatches();
    }

  }

  Finder.prototype = {

    /**
     * Searches for all matches that comply with the instance's 'match' option
     */
    search: function() {

      var match;
      var matchIndex = 0;
      var offset = 0;
      var regex = this.options.find;
      var textAggregation = this.getAggregateText();
      var matches = [];
      var self = this;

      regex = typeof regex === 'string' ? RegExp(escapeRegExp(regex), 'g') : regex;

      matchAggregation(textAggregation);

      function matchAggregation(textAggregation) {
        for (var i = 0, l = textAggregation.length; i < l; ++i) {

          var text = textAggregation[i];

          if (typeof text !== 'string') {
            // Deal with nested contexts: (recursive)
            matchAggregation(text);
            continue;
          }

          if (regex.global) {
            while (match = regex.exec(text)) {
              matches.push(self.prepMatch(match, matchIndex++, offset));
            }
          } else {
            if (match = text.match(regex)) {
              matches.push(self.prepMatch(match, 0, offset));
            }
          }

          offset += text.length;
        }
      }

      return matches;

    },

    /**
     * Prepares a single match with useful meta info:
     */
    prepMatch: function(match, matchIndex, characterOffset) {

      if (!match[0]) {
        throw new Error('findAndReplaceDOMText cannot handle zero-length matches');
      }

      match.endIndex = characterOffset + match.index + match[0].length;
      match.startIndex = characterOffset + match.index;
      match.index = matchIndex;

      return match;
    },

    /**
     * Gets aggregate text within subject node
     */
    getAggregateText: function() {

      var elementFilter = this.options.filterElements;
      var forceContext = this.options.forceContext;

      return getText(this.node);

      /**
       * Gets aggregate text of a node without resorting
       * to broken innerText/textContent
       */
      function getText(node) {

        if (node.nodeType === Node.TEXT_NODE) {
          return [node.data];
        }

        if (elementFilter && !elementFilter(node)) {
          return [];
        }

        var txt = [''];
        var i = 0;

        if (node = node.firstChild) do {

          if (node.nodeType === Node.TEXT_NODE) {
            txt[i] += node.data;
            continue;
          }

          var innerText = getText(node);

          if (
            forceContext &&
            node.nodeType === Node.ELEMENT_NODE &&
            (forceContext === true || forceContext(node))
          ) {
            txt[++i] = innerText;
            txt[++i] = '';
          } else {
            if (typeof innerText[0] === 'string') {
              // Bridge nested text-node data so that they're
              // not considered their own contexts:
              // I.e. ['some', ['thing']] -> ['something']
              txt[i] += innerText.shift();
            }
            if (innerText.length) {
              txt[++i] = innerText;
              txt[++i] = '';
            }
          }
        } while (node = node.nextSibling);

        return txt;

      }

    },

    /**
     * Steps through the target node, looking for matches, and
     * calling replaceFn when a match is found.
     */
    processMatches: function() {

      var matches = this.matches;
      var node = this.node;
      var elementFilter = this.options.filterElements;

      var startPortion,
        endPortion,
        innerPortions = [],
        curNode = node,
        match = matches.shift(),
        atIndex = 0, // i.e. nodeAtIndex
        matchIndex = 0,
        portionIndex = 0,
        doAvoidNode,
        nodeStack = [node];

      out: while (true) {

        if (curNode.nodeType === Node.TEXT_NODE) {

          if (!endPortion && curNode.length + atIndex >= match.endIndex) {
            // We've found the ending
            // (Note that, in the case of a single portion, it'll be an
            // endPortion, not a startPortion.)
            endPortion = {
              node: curNode,
              index: portionIndex++,
              text: curNode.data.substring(match.startIndex - atIndex, match.endIndex - atIndex),

              // If it's the first match (atIndex==0) we should just return 0
              indexInMatch: atIndex === 0 ? 0 : atIndex - match.startIndex,

              indexInNode: match.startIndex - atIndex,
              endIndexInNode: match.endIndex - atIndex,
              isEnd: true
            };

          } else if (startPortion) {
            // Intersecting node
            innerPortions.push({
              node: curNode,
              index: portionIndex++,
              text: curNode.data,
              indexInMatch: atIndex - match.startIndex,
              indexInNode: 0 // always zero for inner-portions
            });
          }

          if (!startPortion && curNode.length + atIndex > match.startIndex) {
            // We've found the match start
            startPortion = {
              node: curNode,
              index: portionIndex++,
              indexInMatch: 0,
              indexInNode: match.startIndex - atIndex,
              endIndexInNode: match.endIndex - atIndex,
              text: curNode.data.substring(match.startIndex - atIndex, match.endIndex - atIndex)
            };
          }

          atIndex += curNode.data.length;

        }

        doAvoidNode = curNode.nodeType === Node.ELEMENT_NODE && elementFilter && !elementFilter(curNode);

        if (startPortion && endPortion) {

          curNode = this.replaceMatch(match, startPortion, innerPortions, endPortion);

          // processMatches has to return the node that replaced the endNode
          // and then we step back so we can continue from the end of the
          // match:

          atIndex -= (endPortion.node.data.length - endPortion.endIndexInNode);

          startPortion = null;
          endPortion = null;
          innerPortions = [];
          match = matches.shift();
          portionIndex = 0;
          matchIndex++;

          if (!match) {
            break; // no more matches
          }

        } else if (
          !doAvoidNode &&
          (curNode.firstChild || curNode.nextSibling)
        ) {
          // Move down or forward:
          if (curNode.firstChild) {
            nodeStack.push(curNode);
            curNode = curNode.firstChild;
          } else {
            curNode = curNode.nextSibling;
          }
          continue;
        }

        // Move forward or up:
        while (true) {
          if (curNode.nextSibling) {
            curNode = curNode.nextSibling;
            break;
          }
          curNode = nodeStack.pop();
          if (curNode === node) {
            break out;
          }
        }

      }

    },

    /**
     * Reverts ... TODO
     */
    revert: function() {
      // Reversion occurs backwards so as to avoid nodes subsequently
      // replaced during the matching phase (a forward process):
      for (var l = this.reverts.length; l--;) {
        this.reverts[l]();
      }
      this.reverts = [];
    },

    prepareReplacementString: function(string, portion, match) {
      var portionMode = this.options.portionMode;
      if (
        portionMode === PORTION_MODE_FIRST &&
        portion.indexInMatch > 0
      ) {
        return '';
      }
      string = string.replace(/\$(\d+|&|`|')/g, function($0, t) {
        var replacement;
        switch(t) {
          case '&':
            replacement = match[0];
            break;
          case '`':
            replacement = match.input.substring(0, match.startIndex);
            break;
          case '\'':
            replacement = match.input.substring(match.endIndex);
            break;
          default:
            replacement = match[+t] || '';
        }
        return replacement;
      });

      if (portionMode === PORTION_MODE_FIRST) {
        return string;
      }

      if (portion.isEnd) {
        return string.substring(portion.indexInMatch);
      }

      return string.substring(portion.indexInMatch, portion.indexInMatch + portion.text.length);
    },

    getPortionReplacementNode: function(portion, match) {

      var replacement = this.options.replace || '$&';
      var wrapper = this.options.wrap;
      var wrapperClass = this.options.wrapClass;

      if (wrapper && wrapper.nodeType) {
        // Wrapper has been provided as a stencil-node for us to clone:
        var clone = doc.createElement('div');
        clone.innerHTML = wrapper.outerHTML || new XMLSerializer().serializeToString(wrapper);
        wrapper = clone.firstChild;
      }

      if (typeof replacement == 'function') {
        replacement = replacement(portion, match);
        if (replacement && replacement.nodeType) {
          return replacement;
        }
        return doc.createTextNode(String(replacement));
      }

      var el = typeof wrapper == 'string' ? doc.createElement(wrapper) : wrapper;

      if (el && wrapperClass) {
        el.className = wrapperClass;
      }

      replacement = doc.createTextNode(
        this.prepareReplacementString(
          replacement, portion, match
        )
      );

      if (!replacement.data) {
        return replacement;
      }

      if (!el) {
        return replacement;
      }

      el.appendChild(replacement);

      return el;
    },

    replaceMatch: function(match, startPortion, innerPortions, endPortion) {

      var matchStartNode = startPortion.node;
      var matchEndNode = endPortion.node;

      var precedingTextNode;
      var followingTextNode;

      if (matchStartNode === matchEndNode) {

        var node = matchStartNode;

        if (startPortion.indexInNode > 0) {
          // Add `before` text node (before the match)
          precedingTextNode = doc.createTextNode(node.data.substring(0, startPortion.indexInNode));
          node.parentNode.insertBefore(precedingTextNode, node);
        }

        // Create the replacement node:
        var newNode = this.getPortionReplacementNode(
          endPortion,
          match
        );

        node.parentNode.insertBefore(newNode, node);

        if (endPortion.endIndexInNode < node.length) { // ?????
          // Add `after` text node (after the match)
          followingTextNode = doc.createTextNode(node.data.substring(endPortion.endIndexInNode));
          node.parentNode.insertBefore(followingTextNode, node);
        }

        node.parentNode.removeChild(node);

        this.reverts.push(function() {
          if (precedingTextNode === newNode.previousSibling) {
            precedingTextNode.parentNode.removeChild(precedingTextNode);
          }
          if (followingTextNode === newNode.nextSibling) {
            followingTextNode.parentNode.removeChild(followingTextNode);
          }
          newNode.parentNode.replaceChild(node, newNode);
        });

        return newNode;

      } else {
        // Replace matchStartNode -> [innerMatchNodes...] -> matchEndNode (in that order)


        precedingTextNode = doc.createTextNode(
          matchStartNode.data.substring(0, startPortion.indexInNode)
        );

        followingTextNode = doc.createTextNode(
          matchEndNode.data.substring(endPortion.endIndexInNode)
        );

        var firstNode = this.getPortionReplacementNode(
          startPortion,
          match
        );

        var innerNodes = [];

        for (var i = 0, l = innerPortions.length; i < l; ++i) {
          var portion = innerPortions[i];
          var innerNode = this.getPortionReplacementNode(
            portion,
            match
          );
          portion.node.parentNode.replaceChild(innerNode, portion.node);
          this.reverts.push((function(portion, innerNode) {
            return function() {
              innerNode.parentNode.replaceChild(portion.node, innerNode);
            };
          }(portion, innerNode)));
          innerNodes.push(innerNode);
        }

        var lastNode = this.getPortionReplacementNode(
          endPortion,
          match
        );

        matchStartNode.parentNode.insertBefore(precedingTextNode, matchStartNode);
        matchStartNode.parentNode.insertBefore(firstNode, matchStartNode);
        matchStartNode.parentNode.removeChild(matchStartNode);

        matchEndNode.parentNode.insertBefore(lastNode, matchEndNode);
        matchEndNode.parentNode.insertBefore(followingTextNode, matchEndNode);
        matchEndNode.parentNode.removeChild(matchEndNode);

        this.reverts.push(function() {
          precedingTextNode.parentNode.removeChild(precedingTextNode);
          firstNode.parentNode.replaceChild(matchStartNode, firstNode);
          followingTextNode.parentNode.removeChild(followingTextNode);
          lastNode.parentNode.replaceChild(matchEndNode, lastNode);
        });

        return lastNode;
      }
    }

  };

  return exposed;

}));

var wordMapJoin = Object.keys(wordMap).join('|');
var regex = new RegExp('\\b(' + wordMapJoin + ')\\b', 'ig');

var startTime = performance.now()
findAndReplaceDOMText(document.body, {
  preset: 'prose',
  find: regex,
  replace: function(portion, match){
    return wordMap[portion.text.toLowerCase()];
    // var kanjiMatch = wordMap[match.toLowerCase()];
    // console.log("the name of the match: " + match + ": " + kanjiMatch);
    // return wordMap[match.toLowerCase()];
  }
});
var executionTime = performance.now() - startTime;
console.log("mapped words in " + executionTime + " ms");
